"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[419],{442:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"ch06-urdf-xacro/index","title":"Chapter 6: URDF and XACRO for Robot Modeling","description":"Learning Objectives","source":"@site/docs/ch06-urdf-xacro/index.md","sourceDirName":"ch06-urdf-xacro","slug":"/ch06-urdf-xacro/","permalink":"/physical-ai-textbook/ch06-urdf-xacro/","draft":false,"unlisted":false,"editUrl":"https://github.com/IlsaFatima1/physical-ai-textbook/tree/main/docs/ch06-urdf-xacro/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 5: NVIDIA Isaac Platform","permalink":"/physical-ai-textbook/ch05-isaac-platform/"},"next":{"title":"Chapter 7: Perception Systems and Computer Vision","permalink":"/physical-ai-textbook/ch07-perception-systems/"}}');var a=r(4848),o=r(8453);const t={},s="Chapter 6: URDF and XACRO for Robot Modeling",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"6.1 Introduction to URDF (Unified Robot Description Format)",id:"61-introduction-to-urdf-unified-robot-description-format",level:2},{value:"6.1.1 Why Robot Description is Important",id:"611-why-robot-description-is-important",level:3},{value:"6.1.2 URDF Core Concepts",id:"612-urdf-core-concepts",level:3},{value:"6.2 URDF Structure and Components",id:"62-urdf-structure-and-components",level:2},{value:"6.2.1 Basic URDF Document Structure",id:"621-basic-urdf-document-structure",level:3},{value:"6.2.2 Link Definition",id:"622-link-definition",level:3},{value:"6.2.3 Joint Definition",id:"623-joint-definition",level:3},{value:"6.3 Advanced URDF Features",id:"63-advanced-urdf-features",level:2},{value:"6.3.1 Materials and Colors",id:"631-materials-and-colors",level:3},{value:"6.3.2 Transmissions",id:"632-transmissions",level:3},{value:"6.3.3 Gazebo-Specific Extensions",id:"633-gazebo-specific-extensions",level:3},{value:"6.4 Introduction to XACRO",id:"64-introduction-to-xacro",level:2},{value:"6.4.1 XACRO Declaration",id:"641-xacro-declaration",level:3},{value:"6.4.2 XACRO Properties (Variables)",id:"642-xacro-properties-variables",level:3},{value:"6.4.3 Mathematical Expressions",id:"643-mathematical-expressions",level:3},{value:"6.5 Creating Complex Robot Models with XACRO",id:"65-creating-complex-robot-models-with-xacro",level:2},{value:"6.5.1 Defining Macros",id:"651-defining-macros",level:3},{value:"6.5.2 Complete XACRO Example",id:"652-complete-xacro-example",level:3},{value:"6.6 URDF Best Practices",id:"66-urdf-best-practices",level:2},{value:"6.6.1 Proper Inertial Properties",id:"661-proper-inertial-properties",level:3},{value:"6.6.2 Collision vs Visual Geometry",id:"662-collision-vs-visual-geometry",level:3},{value:"6.6.3 Proper Origin and Frame Definitions",id:"663-proper-origin-and-frame-definitions",level:3},{value:"6.7 Integrating URDF with ROS 2",id:"67-integrating-urdf-with-ros-2",level:2},{value:"6.7.1 Robot State Publisher",id:"671-robot-state-publisher",level:3},{value:"6.7.2 Launch Configuration",id:"672-launch-configuration",level:3},{value:"6.8 Validation and Debugging",id:"68-validation-and-debugging",level:2},{value:"6.8.1 URDF Validation Tools",id:"681-urdf-validation-tools",level:3},{value:"6.8.2 Common Issues and Solutions",id:"682-common-issues-and-solutions",level:3},{value:"6.8.3 Debugging Techniques",id:"683-debugging-techniques",level:3},{value:"6.9 Advanced XACRO Features",id:"69-advanced-xacro-features",level:2},{value:"6.9.1 Conditional Statements",id:"691-conditional-statements",level:3},{value:"6.9.2 Including Other XACRO Files",id:"692-including-other-xacro-files",level:3},{value:"6.10 Integration with Physical AI Systems",id:"610-integration-with-physical-ai-systems",level:2},{value:"6.10.1 Perception Integration",id:"6101-perception-integration",level:3},{value:"6.10.2 Planning and Control",id:"6102-planning-and-control",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-6-urdf-and-xacro-for-robot-modeling",children:"Chapter 6: URDF and XACRO for Robot Modeling"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Understand the structure and components of Unified Robot Description Format (URDF)"}),"\n",(0,a.jsx)(n.li,{children:"Create complex robot models using URDF with proper kinematic chains"}),"\n",(0,a.jsx)(n.li,{children:"Use XACRO (XML Macros) to simplify and parameterize robot descriptions"}),"\n",(0,a.jsx)(n.li,{children:"Integrate URDF models with ROS 2 for visualization and simulation"}),"\n",(0,a.jsx)(n.li,{children:"Apply best practices for robot modeling and maintainability"}),"\n",(0,a.jsx)(n.li,{children:"Validate URDF models and debug common issues"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"61-introduction-to-urdf-unified-robot-description-format",children:"6.1 Introduction to URDF (Unified Robot Description Format)"}),"\n",(0,a.jsx)(n.p,{children:"Unified Robot Description Format (URDF) is an XML-based format used to describe robots in ROS. It defines the physical and kinematic properties of a robot, including its links, joints, and other associated properties like visual and collision representations."}),"\n",(0,a.jsx)(n.h3,{id:"611-why-robot-description-is-important",children:"6.1.1 Why Robot Description is Important"}),"\n",(0,a.jsx)(n.p,{children:"Robot description is crucial for:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Simulation"}),": Creating accurate simulation models"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visualization"}),": Displaying robots in RViz and other tools"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Kinematic Analysis"}),": Computing forward and inverse kinematics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Collision Detection"}),": Determining when parts of a robot collide"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Motion Planning"}),": Planning paths while avoiding self-collision"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"612-urdf-core-concepts",children:"6.1.2 URDF Core Concepts"}),"\n",(0,a.jsx)(n.p,{children:"URDF models consist of two fundamental elements:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Links"}),": Rigid bodies with physical properties (mass, inertia, visual representation)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Joints"}),": Connections between links that constrain their relative motion"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"62-urdf-structure-and-components",children:"6.2 URDF Structure and Components"}),"\n",(0,a.jsx)(n.h3,{id:"621-basic-urdf-document-structure",children:"6.2.1 Basic URDF Document Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="my_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n  \x3c!-- Links definition --\x3e\r\n  <link name="base_link">\r\n    \x3c!-- Link properties --\x3e\r\n  </link>\r\n\r\n  \x3c!-- Joints definition --\x3e\r\n  <joint name="joint_name" type="joint_type">\r\n    <parent link="parent_link_name"/>\r\n    <child link="child_link_name"/>\r\n  </joint>\r\n\r\n  \x3c!-- Other elements (materials, transmissions, etc.) --\x3e\r\n</robot>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"622-link-definition",children:"6.2.2 Link Definition"}),"\n",(0,a.jsx)(n.p,{children:"A link represents a rigid body in the robot and contains several sub-elements:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<link name="link_name">\r\n  \x3c!-- Inertial properties --\x3e\r\n  <inertial>\r\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n    <mass value="1.0"/>\r\n    <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\r\n  </inertial>\r\n\r\n  \x3c!-- Visual properties --\x3e\r\n  <visual>\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n    <geometry>\r\n      <box size="0.5 0.5 0.2"/>\r\n    </geometry>\r\n    <material name="blue">\r\n      <color rgba="0 0 1 1"/>\r\n    </material>\r\n  </visual>\r\n\r\n  \x3c!-- Collision properties --\x3e\r\n  <collision>\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n    <geometry>\r\n      <box size="0.5 0.5 0.2"/>\r\n    </geometry>\r\n  </collision>\r\n</link>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"623-joint-definition",children:"6.2.3 Joint Definition"}),"\n",(0,a.jsx)(n.p,{children:"Joints define the connection between links and their allowed motion:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<joint name="joint_name" type="joint_type">\r\n  <parent link="parent_link_name"/>\r\n  <child link="child_link_name"/>\r\n  <origin xyz="0.1 0 0" rpy="0 0 0"/>\r\n  <axis xyz="0 0 1"/>\r\n  <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\r\n  <dynamics damping="0.1" friction="0.0"/>\r\n</joint>\n'})}),"\n",(0,a.jsx)(n.p,{children:"Joint types include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"revolute"}),": Rotational joint with limited range"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"continuous"}),": Rotational joint without limits"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"prismatic"}),": Linear sliding joint with limits"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"fixed"}),": No relative motion between links"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"floating"}),": 6 DOF with no constraints"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"planar"}),": Motion on a plane"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"63-advanced-urdf-features",children:"6.3 Advanced URDF Features"}),"\n",(0,a.jsx)(n.h3,{id:"631-materials-and-colors",children:"6.3.1 Materials and Colors"}),"\n",(0,a.jsx)(n.p,{children:"Materials can be defined separately and referenced by links:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<material name="red">\r\n  <color rgba="1 0 0 1"/>\r\n</material>\r\n\r\n<material name="blue">\r\n  <color rgba="0 0 1 1"/>\r\n</material>\r\n\r\n<link name="example_link">\r\n  <visual>\r\n    <geometry>\r\n      <box size="0.1 0.1 0.1"/>\r\n    </geometry>\r\n    <material name="red"/>\r\n  </visual>\r\n</link>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"632-transmissions",children:"6.3.2 Transmissions"}),"\n",(0,a.jsx)(n.p,{children:"Transmissions define how joints connect to actuators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<transmission name="wheel_transmission">\r\n  <type>transmission_interface/SimpleTransmission</type>\r\n  <joint name="wheel_joint">\r\n    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>\r\n  </joint>\r\n  <actuator name="wheel_motor">\r\n    <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>\r\n    <mechanicalReduction>1</mechanicalReduction>\r\n  </actuator>\r\n</transmission>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"633-gazebo-specific-extensions",children:"6.3.3 Gazebo-Specific Extensions"}),"\n",(0,a.jsx)(n.p,{children:"URDF can include Gazebo-specific elements for simulation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="link_name">\r\n  <material>Gazebo/Blue</material>\r\n  <mu1>0.2</mu1>\r\n  <mu2>0.2</mu2>\r\n  <kp>1000000.0</kp>\r\n  <kd>100.0</kd>\r\n</gazebo>\r\n\r\n<gazebo>\r\n  <plugin name="differential_drive" filename="libgazebo_ros_diff_drive.so">\r\n    <left_joint>left_wheel_joint</left_joint>\r\n    <right_joint>right_wheel_joint</right_joint>\r\n    <wheel_separation>0.4</wheel_separation>\r\n    <wheel_diameter>0.2</wheel_diameter>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,a.jsx)(n.h2,{id:"64-introduction-to-xacro",children:"6.4 Introduction to XACRO"}),"\n",(0,a.jsx)(n.p,{children:"XACRO (XML Macros) is a macro language for XML that extends URDF with features like variables, mathematical expressions, and macros. It makes complex robot descriptions more manageable and reusable."}),"\n",(0,a.jsx)(n.h3,{id:"641-xacro-declaration",children:"6.4.1 XACRO Declaration"}),"\n",(0,a.jsx)(n.p,{children:"To use XACRO, declare it in the robot tag:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="robot_with_xacro">\r\n  \x3c!-- XACRO content --\x3e\r\n</robot>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"642-xacro-properties-variables",children:"6.4.2 XACRO Properties (Variables)"}),"\n",(0,a.jsx)(n.p,{children:"Define reusable values using properties:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<xacro:property name="M_PI" value="3.1415926535897931" />\r\n<xacro:property name="wheel_radius" value="0.05" />\r\n<xacro:property name="wheel_width" value="0.02" />\r\n<xacro:property name="base_length" value="0.5" />\r\n<xacro:property name="base_width" value="0.4" />\r\n<xacro:property name="base_height" value="0.2" />\n'})}),"\n",(0,a.jsx)(n.h3,{id:"643-mathematical-expressions",children:"6.4.3 Mathematical Expressions"}),"\n",(0,a.jsx)(n.p,{children:"XACRO supports mathematical operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<xacro:property name="wheel_offset_x" value="${base_length/2 - wheel_width/2}" />\r\n<xacro:property name="wheel_offset_y" value="${base_width/2 + wheel_radius}" />\n'})}),"\n",(0,a.jsx)(n.h2,{id:"65-creating-complex-robot-models-with-xacro",children:"6.5 Creating Complex Robot Models with XACRO"}),"\n",(0,a.jsx)(n.h3,{id:"651-defining-macros",children:"6.5.1 Defining Macros"}),"\n",(0,a.jsx)(n.p,{children:"Macros allow reusing common patterns:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<xacro:macro name="wheel" params="prefix parent xyz rpy">\r\n  <joint name="${prefix}_wheel_joint" type="continuous">\r\n    <parent link="${parent}"/>\r\n    <child link="${prefix}_wheel"/>\r\n    <origin xyz="${xyz}" rpy="${rpy}"/>\r\n    <axis xyz="0 1 0"/>\r\n  </joint>\r\n\r\n  <link name="${prefix}_wheel">\r\n    <inertial>\r\n      <mass value="0.2"/>\r\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\r\n    </inertial>\r\n    <visual>\r\n      <geometry>\r\n        <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n      </geometry>\r\n      <material name="black">\r\n        <color rgba="0 0 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n</xacro:macro>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"652-complete-xacro-example",children:"6.5.2 Complete XACRO Example"}),"\n",(0,a.jsx)(n.p,{children:"Here's a complete example of a differential drive robot using XACRO:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="diff_drive_robot">\r\n\r\n  \x3c!-- Properties --\x3e\r\n  <xacro:property name="M_PI" value="3.1415926535897931" />\r\n  <xacro:property name="wheel_radius" value="0.05" />\r\n  <xacro:property name="wheel_width" value="0.02" />\r\n  <xacro:property name="base_length" value="0.5" />\r\n  <xacro:property name="base_width" value="0.4" />\r\n  <xacro:property name="base_height" value="0.2" />\r\n  <xacro:property name="wheel_offset_x" value="${base_length/2 - wheel_width/2}" />\r\n  <xacro:property name="wheel_offset_y" value="${base_width/2 + wheel_radius}" />\r\n\r\n  \x3c!-- Base link --\x3e\r\n  <link name="base_link">\r\n    <inertial>\r\n      <mass value="10.0"/>\r\n      <origin xyz="0 0 0"/>\r\n      <inertia ixx="0.416" ixy="0" ixz="0" iyy="0.583" iyz="0" izz="0.194"/>\r\n    </inertial>\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${base_length} ${base_width} ${base_height}"/>\r\n      </geometry>\r\n      <material name="orange">\r\n        <color rgba="1 0.5 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${base_length} ${base_width} ${base_height}"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Wheel macro --\x3e\r\n  <xacro:macro name="wheel" params="prefix reflect">\r\n    <joint name="${prefix}_wheel_joint" type="continuous">\r\n      <parent link="base_link"/>\r\n      <child link="${prefix}_wheel"/>\r\n      <origin xyz="${wheel_offset_x*reflect} 0 -${base_height/2}" rpy="${-M_PI/2} 0 0"/>\r\n      <axis xyz="0 0 1"/>\r\n    </joint>\r\n\r\n    <link name="${prefix}_wheel">\r\n      <inertial>\r\n        <mass value="0.5"/>\r\n        <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>\r\n      </inertial>\r\n      <visual>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n        <material name="black">\r\n          <color rgba="0 0 0 1"/>\r\n        </material>\r\n      </visual>\r\n      <collision>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n      </collision>\r\n    </link>\r\n  </xacro:macro>\r\n\r\n  \x3c!-- Instantiate wheels --\x3e\r\n  <xacro:wheel prefix="left" reflect="1"/>\r\n  <xacro:wheel prefix="right" reflect="-1"/>\r\n\r\n  \x3c!-- Castor wheel --\x3e\r\n  <joint name="caster_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="caster_wheel"/>\r\n    <origin xyz="${-base_length/2} 0 -${base_height/2 - 0.01}" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  <link name="caster_wheel">\r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\r\n    </inertial>\r\n    <visual>\r\n      <geometry>\r\n        <sphere radius="0.02"/>\r\n      </geometry>\r\n      <material name="gray">\r\n        <color rgba="0.5 0.5 0.5 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <sphere radius="0.02"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n</robot>\n'})}),"\n",(0,a.jsx)(n.h2,{id:"66-urdf-best-practices",children:"6.6 URDF Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"661-proper-inertial-properties",children:"6.6.1 Proper Inertial Properties"}),"\n",(0,a.jsx)(n.p,{children:"Accurate inertial properties are crucial for simulation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<inertial>\r\n  <mass value="1.0"/>\r\n  <inertia\r\n    ixx="0.083" ixy="0" ixz="0"\r\n    iyy="0.083" iyz="0"\r\n    izz="0.166"/>\r\n</inertial>\n'})}),"\n",(0,a.jsx)(n.p,{children:"For common shapes, use these formulas:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Box: ",(0,a.jsx)(n.code,{children:"Ixx = m*(h\xb2 + d\xb2)/12"}),", ",(0,a.jsx)(n.code,{children:"Iyy = m*(w\xb2 + d\xb2)/12"}),", ",(0,a.jsx)(n.code,{children:"Izz = m*(w\xb2 + h\xb2)/12"})]}),"\n",(0,a.jsxs)(n.li,{children:["Cylinder: ",(0,a.jsx)(n.code,{children:"Ixx = Iyy = m*(3*r\xb2 + h\xb2)/12"}),", ",(0,a.jsx)(n.code,{children:"Izz = m*r\xb2/2"})]}),"\n",(0,a.jsxs)(n.li,{children:["Sphere: ",(0,a.jsx)(n.code,{children:"Ixx = Iyy = Izz = 2*m*r\xb2/5"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"662-collision-vs-visual-geometry",children:"6.6.2 Collision vs Visual Geometry"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use simple shapes for collision geometry (boxes, cylinders, spheres)"}),"\n",(0,a.jsx)(n.li,{children:"Use detailed meshes for visual geometry"}),"\n",(0,a.jsx)(n.li,{children:"Ensure collision geometry completely contains visual geometry"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"663-proper-origin-and-frame-definitions",children:"6.6.3 Proper Origin and Frame Definitions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use consistent coordinate frames (typically X-forward, Y-left, Z-up)"}),"\n",(0,a.jsx)(n.li,{children:"Define origins relative to the parent link's coordinate frame"}),"\n",(0,a.jsx)(n.li,{children:"Use proper rotation conventions (roll-pitch-yaw)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"67-integrating-urdf-with-ros-2",children:"6.7 Integrating URDF with ROS 2"}),"\n",(0,a.jsx)(n.h3,{id:"671-robot-state-publisher",children:"6.7.1 Robot State Publisher"}),"\n",(0,a.jsx)(n.p,{children:"The robot_state_publisher node reads the URDF and publishes TF transforms:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom tf2_ros import TransformBroadcaster\r\nimport math\r\n\r\nclass RobotStatePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('robot_state_publisher')\r\n\r\n        # Read URDF from parameter server or file\r\n        self.declare_parameter('robot_description', '')\r\n\r\n        # Subscribe to joint states\r\n        self.joint_sub = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        # Setup TF broadcaster\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n\r\n    def joint_state_callback(self, msg):\r\n        \"\"\"Process joint state messages and publish transforms\"\"\"\r\n        # Process each joint and publish corresponding transform\r\n        for i, joint_name in enumerate(msg.name):\r\n            # Create and publish transform for each joint\r\n            pass\n"})}),"\n",(0,a.jsx)(n.h3,{id:"672-launch-configuration",children:"6.7.2 Launch Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Create a launch file to start the robot state publisher with URDF:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# launch/robot_state_publisher.launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Declare launch arguments\r\n    urdf_package = DeclareLaunchArgument(\r\n        'urdf_package',\r\n        default_value='my_robot_description',\r\n        description='Package containing robot URDF files'\r\n    )\r\n\r\n    urdf_file = DeclareLaunchArgument(\r\n        'urdf_file',\r\n        default_value='robot.urdf.xacro',\r\n        description='URDF file name'\r\n    )\r\n\r\n    # Find URDF file\r\n    robot_description_path = PathJoinSubstitution([\r\n        FindPackageShare(LaunchConfiguration('urdf_package')),\r\n        'urdf',\r\n        LaunchConfiguration('urdf_file')\r\n    ])\r\n\r\n    # Robot state publisher node\r\n    robot_state_publisher = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        parameters=[{\r\n            'robot_description': PathJoinSubstitution([\r\n                FindPackageShare(LaunchConfiguration('urdf_package')),\r\n                'urdf',\r\n                LaunchConfiguration('urdf_file')\r\n            ])\r\n        }]\r\n    )\r\n\r\n    return LaunchDescription([\r\n        urdf_package,\r\n        urdf_file,\r\n        robot_state_publisher\r\n    ])\n"})}),"\n",(0,a.jsx)(n.h2,{id:"68-validation-and-debugging",children:"6.8 Validation and Debugging"}),"\n",(0,a.jsx)(n.h3,{id:"681-urdf-validation-tools",children:"6.8.1 URDF Validation Tools"}),"\n",(0,a.jsx)(n.p,{children:"ROS provides tools for validating URDF models:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Check URDF syntax\r\ncheck_urdf /path/to/robot.urdf\r\n\r\n# Parse XACRO to URDF\r\nxacro input_file.xacro > output_file.urdf\r\n\r\n# Visualize in RViz\r\nros2 launch rviz2 rviz2\n"})}),"\n",(0,a.jsx)(n.h3,{id:"682-common-issues-and-solutions",children:"6.8.2 Common Issues and Solutions"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Self-collision"}),": Check joint limits and ensure proper spacing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Kinematic errors"}),": Verify joint types and axis directions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Inertial issues"}),": Use proper mass and inertia values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visual artifacts"}),": Check geometry definitions and materials"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"683-debugging-techniques",children:"6.8.3 Debugging Techniques"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Python script to check URDF model\r\nimport xml.etree.ElementTree as ET\r\n\r\ndef validate_urdf(urdf_path):\r\n    \"\"\"Validate basic URDF structure\"\"\"\r\n    try:\r\n        tree = ET.parse(urdf_path)\r\n        root = tree.getroot()\r\n\r\n        # Check for required elements\r\n        links = root.findall('link')\r\n        joints = root.findall('joint')\r\n\r\n        print(f\"URDF contains {len(links)} links and {len(joints)} joints\")\r\n\r\n        # Check for proper joint connections\r\n        link_names = [link.get('name') for link in links]\r\n        for joint in joints:\r\n            parent = joint.find('parent').get('link')\r\n            child = joint.find('child').get('link')\r\n\r\n            if parent not in link_names:\r\n                print(f\"Error: Joint {joint.get('name')} references non-existent parent link {parent}\")\r\n            if child not in link_names:\r\n                print(f\"Error: Joint {joint.get('name')} references non-existent child link {child}\")\r\n\r\n    except ET.ParseError as e:\r\n        print(f\"XML Parse Error: {e}\")\r\n    except Exception as e:\r\n        print(f\"Error validating URDF: {e}\")\n"})}),"\n",(0,a.jsx)(n.h2,{id:"69-advanced-xacro-features",children:"6.9 Advanced XACRO Features"}),"\n",(0,a.jsx)(n.h3,{id:"691-conditional-statements",children:"6.9.1 Conditional Statements"}),"\n",(0,a.jsx)(n.p,{children:"XACRO supports conditional processing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<xacro:property name="use_gpu" value="true" />\r\n\r\n<xacro:if value="$(arg use_gpu)">\r\n  <gazebo reference="sensor_link">\r\n    <sensor type="gpu_ray" name="gpu_laser">\r\n      \x3c!-- GPU-accelerated sensor configuration --\x3e\r\n    </sensor>\r\n  </gazebo>\r\n</xacro:if>\r\n\r\n<xacro:unless value="$(arg use_gpu)">\r\n  <gazebo reference="sensor_link">\r\n    <sensor type="ray" name="laser">\r\n      \x3c!-- CPU-based sensor configuration --\x3e\r\n    </sensor>\r\n  </gazebo>\r\n</xacro:unless>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"692-including-other-xacro-files",children:"6.9.2 Including Other XACRO Files"}),"\n",(0,a.jsx)(n.p,{children:"Break down complex models into modular files:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Include common components --\x3e\r\n<xacro:include filename="$(find my_robot_description)/urdf/materials.xacro" />\r\n<xacro:include filename="$(find my_robot_description)/urdf/wheel.xacro" />\r\n<xacro:include filename="$(find my_robot_description)/urdf/sensors.xacro" />\r\n\r\n\x3c!-- Use included components --\x3e\r\n<xacro:wheel prefix="front_left"/>\r\n<xacro:wheel prefix="front_right"/>\n'})}),"\n",(0,a.jsx)(n.h2,{id:"610-integration-with-physical-ai-systems",children:"6.10 Integration with Physical AI Systems"}),"\n",(0,a.jsx)(n.p,{children:"URDF models play a crucial role in Physical AI systems by providing the geometric and kinematic foundation for perception, planning, and control algorithms."}),"\n",(0,a.jsx)(n.h3,{id:"6101-perception-integration",children:"6.10.1 Perception Integration"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Accurate collision geometry enables proper collision detection"}),"\n",(0,a.jsx)(n.li,{children:"Visual models provide realistic rendering for simulation"}),"\n",(0,a.jsx)(n.li,{children:"Proper inertial properties enable realistic physics simulation"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"6102-planning-and-control",children:"6.10.2 Planning and Control"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Kinematic models enable forward and inverse kinematics"}),"\n",(0,a.jsx)(n.li,{children:"Joint limits and types inform motion planning algorithms"}),"\n",(0,a.jsx)(n.li,{children:"Mass properties affect dynamic planning and control"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"URDF and XACRO are fundamental tools for robot modeling in ROS 2. URDF provides the basic structure for describing robot geometry, kinematics, and dynamics, while XACRO extends this with powerful macro capabilities that make complex models more manageable. Proper use of these tools enables accurate simulation, visualization, and control of robotic systems. The combination of clear structure, parameterization capabilities, and integration with ROS 2 tools makes URDF and XACRO essential for developing sophisticated Physical AI systems."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>s});var i=r(6540);const a={},o=i.createContext(a);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);