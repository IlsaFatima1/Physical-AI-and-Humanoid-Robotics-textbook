"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[788],{3967:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"ch08-navigation/index","title":"Chapter 8: Mobile Robot Navigation and Path Planning","description":"Learning Objectives","source":"@site/docs/ch08-navigation/index.md","sourceDirName":"ch08-navigation","slug":"/ch08-navigation/","permalink":"/physical-ai-textbook/ch08-navigation/","draft":false,"unlisted":false,"editUrl":"https://github.com/IlsaFatima1/physical-ai-textbook/tree/main/docs/ch08-navigation/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Chapter 7: Perception Systems and Computer Vision","permalink":"/physical-ai-textbook/ch07-perception-systems/"},"next":{"title":"Chapter 9: Manipulation and Control Systems","permalink":"/physical-ai-textbook/ch09-manipulation/"}}');var a=r(4848),o=r(8453);const i={},s="Chapter 8: Mobile Robot Navigation and Path Planning",l={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"8.1 Introduction to Mobile Robot Navigation",id:"81-introduction-to-mobile-robot-navigation",level:2},{value:"8.1.1 The Navigation Stack",id:"811-the-navigation-stack",level:3},{value:"8.1.2 Navigation Challenges",id:"812-navigation-challenges",level:3},{value:"8.2 Localization and Mapping",id:"82-localization-and-mapping",level:2},{value:"8.2.1 Simultaneous Localization and Mapping (SLAM)",id:"821-simultaneous-localization-and-mapping-slam",level:3},{value:"8.2.2 Occupancy Grid Mapping",id:"822-occupancy-grid-mapping",level:3},{value:"8.3 Path Planning Algorithms",id:"83-path-planning-algorithms",level:2},{value:"8.3.1 A* Algorithm",id:"831-a-algorithm",level:3},{value:"8.3.2 Dijkstra&#39;s Algorithm",id:"832-dijkstras-algorithm",level:3},{value:"8.3.3 RRT (Rapidly-exploring Random Trees)",id:"833-rrt-rapidly-exploring-random-trees",level:3},{value:"8.4 ROS 2 Navigation Integration",id:"84-ros-2-navigation-integration",level:2},{value:"8.4.1 Navigation2 Stack Components",id:"841-navigation2-stack-components",level:3},{value:"8.5 Motion Planning and Trajectory Generation",id:"85-motion-planning-and-trajectory-generation",level:2},{value:"8.5.1 Trajectory Optimization",id:"851-trajectory-optimization",level:3},{value:"8.5.2 Dynamic Window Approach (DWA)",id:"852-dynamic-window-approach-dwa",level:3},{value:"8.6 Behavior-Based Navigation",id:"86-behavior-based-navigation",level:2},{value:"8.6.1 Reactive Navigation Behaviors",id:"861-reactive-navigation-behaviors",level:3},{value:"8.7 Integration with Physical AI Systems",id:"87-integration-with-physical-ai-systems",level:2},{value:"8.7.1 Perception-Action Integration",id:"871-perception-action-integration",level:3},{value:"8.8 Performance Evaluation and Safety",id:"88-performance-evaluation-and-safety",level:2},{value:"8.8.1 Navigation Metrics",id:"881-navigation-metrics",level:3},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-8-mobile-robot-navigation-and-path-planning",children:"Chapter 8: Mobile Robot Navigation and Path Planning"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand the fundamental concepts of mobile robot navigation and path planning"}),"\n",(0,a.jsx)(e.li,{children:"Implement classical and modern path planning algorithms"}),"\n",(0,a.jsx)(e.li,{children:"Integrate navigation systems with ROS 2 and perception modules"}),"\n",(0,a.jsx)(e.li,{children:"Design behavior-based navigation systems for dynamic environments"}),"\n",(0,a.jsx)(e.li,{children:"Apply motion planning techniques for obstacle avoidance and trajectory generation"}),"\n",(0,a.jsx)(e.li,{children:"Evaluate navigation system performance and handle uncertainty in real-world scenarios"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"81-introduction-to-mobile-robot-navigation",children:"8.1 Introduction to Mobile Robot Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Mobile robot navigation is the process by which a robot determines how to move from its current location to a desired goal while avoiding obstacles and respecting environmental constraints. Navigation systems are fundamental to autonomous robotics, enabling robots to operate effectively in unstructured environments."}),"\n",(0,a.jsx)(e.h3,{id:"811-the-navigation-stack",children:"8.1.1 The Navigation Stack"}),"\n",(0,a.jsx)(e.p,{children:"Modern mobile robot navigation typically follows a hierarchical structure:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Localization"}),": Determining the robot's position in the environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Mapping"}),": Creating or updating a representation of the environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path Planning"}),": Computing a geometric path from start to goal"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Motion Planning"}),": Generating time-parameterized trajectories"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control"}),": Executing the planned motions while handling real-time feedback"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"812-navigation-challenges",children:"8.1.2 Navigation Challenges"}),"\n",(0,a.jsx)(e.p,{children:"Mobile robot navigation faces several key challenges:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Perception Uncertainty"}),": Sensor noise and limited field of view"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic Environments"}),": Moving obstacles and changing conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time Constraints"}),": Need for fast computation and response"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety Requirements"}),": Avoiding collisions and ensuring system safety"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Computational Complexity"}),": Balancing accuracy with efficiency"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"82-localization-and-mapping",children:"8.2 Localization and Mapping"}),"\n",(0,a.jsx)(e.h3,{id:"821-simultaneous-localization-and-mapping-slam",children:"8.2.1 Simultaneous Localization and Mapping (SLAM)"}),"\n",(0,a.jsx)(e.p,{children:"SLAM is the process of building a map of an unknown environment while simultaneously localizing the robot within that map. This is fundamental for navigation in previously unmapped environments."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\nimport math\r\n\r\nclass ParticleFilterSLAM:\r\n    def __init__(self, num_particles=100):\r\n        self.num_particles = num_particles\r\n        self.particles = self.initialize_particles()\r\n        self.map = {}  # Dictionary to store landmarks\r\n\r\n    def initialize_particles(self):\r\n        \"\"\"Initialize particles with random poses\"\"\"\r\n        particles = []\r\n        for _ in range(self.num_particles):\r\n            # Random pose (x, y, theta)\r\n            pose = np.random.uniform(-10, 10, 3)\r\n            weight = 1.0 / self.num_particles\r\n            particles.append({'pose': pose, 'weight': weight, 'landmarks': {}})\r\n        return particles\r\n\r\n    def predict_motion(self, control_input, dt):\r\n        \"\"\"Predict robot motion using odometry model\"\"\"\r\n        for particle in self.particles:\r\n            # Add noise to control input\r\n            noisy_control = control_input + np.random.normal(0, 0.1, 2)\r\n\r\n            # Update pose based on control input\r\n            x, y, theta = particle['pose']\r\n            v, omega = noisy_control\r\n\r\n            # Differential drive motion model\r\n            if abs(omega) < 1e-6:  # Straight line motion\r\n                x_new = x + v * dt * math.cos(theta)\r\n                y_new = y + v * dt * math.sin(theta)\r\n                theta_new = theta\r\n            else:  # Circular motion\r\n                radius = v / omega\r\n                x_new = x + radius * (math.sin(theta + omega * dt) - math.sin(theta))\r\n                y_new = y + radius * (math.cos(theta) - math.cos(theta + omega * dt))\r\n                theta_new = theta + omega * dt\r\n\r\n            particle['pose'] = np.array([x_new, y_new, theta_new])\r\n\r\n    def update_weights(self, sensor_data):\r\n        \"\"\"Update particle weights based on sensor observations\"\"\"\r\n        for particle in self.particles:\r\n            weight = 1.0\r\n            for obs in sensor_data:\r\n                # Calculate expected observation based on particle's map\r\n                expected_obs = self.calculate_expected_observation(particle, obs['landmark_id'])\r\n                if expected_obs is not None:\r\n                    # Calculate likelihood of observation\r\n                    likelihood = self.calculate_observation_likelihood(obs, expected_obs)\r\n                    weight *= likelihood\r\n\r\n            particle['weight'] = weight\r\n\r\n        # Normalize weights\r\n        total_weight = sum(p['weight'] for p in self.particles)\r\n        if total_weight > 0:\r\n            for particle in self.particles:\r\n                particle['weight'] /= total_weight\r\n\r\n    def calculate_expected_observation(self, particle, landmark_id):\r\n        \"\"\"Calculate expected sensor observation for a landmark\"\"\"\r\n        if landmark_id in particle['landmarks']:\r\n            landmark_pos = particle['landmarks'][landmark_id]\r\n            robot_x, robot_y, robot_theta = particle['pose']\r\n\r\n            # Calculate expected range and bearing\r\n            dx = landmark_pos[0] - robot_x\r\n            dy = landmark_pos[1] - robot_y\r\n            expected_range = math.sqrt(dx*dx + dy*dy)\r\n            expected_bearing = math.atan2(dy, dx) - robot_theta\r\n\r\n            return {'range': expected_range, 'bearing': expected_bearing}\r\n        return None\r\n\r\n    def calculate_observation_likelihood(self, observed, expected):\r\n        \"\"\"Calculate likelihood of observation given expected value\"\"\"\r\n        if expected is None:\r\n            return 0.01  # Low likelihood if landmark not in map\r\n\r\n        range_diff = observed['range'] - expected['range']\r\n        bearing_diff = observed['bearing'] - expected['bearing']\r\n\r\n        # Normalize bearing difference\r\n        bearing_diff = (bearing_diff + math.pi) % (2 * math.pi) - math.pi\r\n\r\n        # Gaussian likelihood\r\n        range_likelihood = math.exp(-0.5 * (range_diff / 0.5)**2)\r\n        bearing_likelihood = math.exp(-0.5 * (bearing_diff / 0.1)**2)\r\n\r\n        return range_likelihood * bearing_likelihood\r\n\r\n    def resample(self):\r\n        \"\"\"Resample particles based on their weights\"\"\"\r\n        weights = [p['weight'] for p in self.particles]\r\n        indices = np.random.choice(len(self.particles), size=self.num_particles, p=weights)\r\n\r\n        new_particles = []\r\n        for idx in indices:\r\n            new_particles.append(self.particles[idx].copy())\r\n\r\n        self.particles = new_particles\r\n\r\n        # Reset weights\r\n        for particle in self.particles:\r\n            particle['weight'] = 1.0 / self.num_particles\n"})}),"\n",(0,a.jsx)(e.h3,{id:"822-occupancy-grid-mapping",children:"8.2.2 Occupancy Grid Mapping"}),"\n",(0,a.jsx)(e.p,{children:"Occupancy grid mapping represents the environment as a 2D grid where each cell contains the probability of being occupied:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class OccupancyGridMap:\r\n    def __init__(self, width, height, resolution=0.1):\r\n        self.width = width\r\n        self.height = height\r\n        self.resolution = resolution  # meters per cell\r\n        self.grid = np.full((height, width), 0.5)  # Initialize to unknown (0.5)\r\n\r\n        # Log odds representation for efficient updates\r\n        self.log_odds = np.zeros((height, width))\r\n\r\n        # Conversion factors\r\n        self.origin_x = 0.0\r\n        self.origin_y = 0.0\r\n\r\n    def world_to_grid(self, x, y):\r\n        """Convert world coordinates to grid coordinates"""\r\n        grid_x = int((x - self.origin_x) / self.resolution)\r\n        grid_y = int((y - self.origin_y) / self.resolution)\r\n        return grid_x, grid_y\r\n\r\n    def grid_to_world(self, grid_x, grid_y):\r\n        """Convert grid coordinates to world coordinates"""\r\n        x = grid_x * self.resolution + self.origin_x\r\n        y = grid_y * self.resolution + self.origin_y\r\n        return x, y\r\n\r\n    def update_with_laser_scan(self, robot_pose, scan_ranges, scan_angles):\r\n        """Update grid based on laser scan data"""\r\n        robot_x, robot_y, robot_theta = robot_pose\r\n\r\n        # Convert scan to world coordinates\r\n        for i, (range_val, angle) in enumerate(zip(scan_ranges, scan_angles)):\r\n            if range_val < 0.1 or range_val > 30.0:  # Invalid range\r\n                continue\r\n\r\n            # Calculate endpoint of this ray\r\n            world_x = robot_x + range_val * math.cos(robot_theta + angle)\r\n            world_y = robot_y + range_val * math.sin(robot_theta + angle)\r\n\r\n            # Get grid coordinates\r\n            end_grid_x, end_grid_y = self.world_to_grid(world_x, world_y)\r\n            start_grid_x, start_grid_y = self.world_to_grid(robot_x, robot_y)\r\n\r\n            # Perform ray tracing to update grid\r\n            self.ray_trace(start_grid_x, start_grid_y, end_grid_x, end_grid_y, range_val < 29.0)  # endpoint is obstacle if not max range\r\n\r\n    def ray_trace(self, x0, y0, x1, y1, endpoint_occupied):\r\n        """Perform ray tracing between two points"""\r\n        # Bresenham\'s line algorithm with probability updates\r\n        dx = abs(x1 - x0)\r\n        dy = abs(y1 - y0)\r\n        x_step = 1 if x0 < x1 else -1\r\n        y_step = 1 if y0 < y1 else -1\r\n\r\n        error = dx - dy\r\n        x, y = x0, y0\r\n\r\n        # Update cells along the ray\r\n        while x != x1 or y != y1:\r\n            if 0 <= x < self.width and 0 <= y < self.height:\r\n                # Update log odds (free space)\r\n                self.log_odds[y, x] += self.log_odds_from_probability(0.4)  # Free space\r\n\r\n            if error * 2 > -dy:\r\n                error -= dy\r\n                x += x_step\r\n            if error * 2 < dx:\r\n                error += dx\r\n                y += y_step\r\n\r\n        # Update endpoint\r\n        if 0 <= x1 < self.width and 0 <= y1 < self.height:\r\n            if endpoint_occupied:\r\n                # Update log odds (occupied space)\r\n                self.log_odds[y1, x1] += self.log_odds_from_probability(0.8)  # Occupied space\r\n            else:\r\n                # Update log odds (free space)\r\n                self.log_odds[y1, x1] += self.log_odds_from_probability(0.3)  # Free space\r\n\r\n    def log_odds_from_probability(self, prob):\r\n        """Convert probability to log odds"""\r\n        prob = max(0.01, min(0.99, prob))  # Clamp to avoid log(0)\r\n        return math.log(prob / (1 - prob))\r\n\r\n    def probability_from_log_odds(self, log_odds):\r\n        """Convert log odds to probability"""\r\n        prob = 1 - 1 / (1 + math.exp(log_odds))\r\n        return prob\r\n\r\n    def get_probability(self, x, y):\r\n        """Get occupancy probability at world coordinates"""\r\n        grid_x, grid_y = self.world_to_grid(x, y)\r\n        if 0 <= grid_x < self.width and 0 <= grid_y < self.height:\r\n            return self.probability_from_log_odds(self.log_odds[grid_y, grid_x])\r\n        return 0.5  # Unknown area\n'})}),"\n",(0,a.jsx)(e.h2,{id:"83-path-planning-algorithms",children:"8.3 Path Planning Algorithms"}),"\n",(0,a.jsx)(e.h3,{id:"831-a-algorithm",children:"8.3.1 A* Algorithm"}),"\n",(0,a.jsx)(e.p,{children:"A* is a popular graph search algorithm that finds the shortest path between start and goal while considering heuristic information:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import heapq\r\nfrom typing import List, Tuple\r\n\r\nclass AStarPlanner:\r\n    def __init__(self, grid_map):\r\n        self.grid_map = grid_map\r\n        self.height, self.width = grid_map.shape\r\n\r\n    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\r\n        """Plan path using A* algorithm"""\r\n        # Check if start and goal are valid\r\n        if not self.is_valid_cell(start[0], start[1]) or not self.is_valid_cell(goal[0], goal[1]):\r\n            return []\r\n\r\n        # Initialize data structures\r\n        open_set = [(0, start)]  # (f_score, position)\r\n        came_from = {}\r\n        g_score = {start: 0}\r\n        f_score = {start: self.heuristic(start, goal)}\r\n\r\n        while open_set:\r\n            current_f, current = heapq.heappop(open_set)\r\n\r\n            if current == goal:\r\n                return self.reconstruct_path(came_from, current)\r\n\r\n            # Explore neighbors\r\n            for neighbor in self.get_neighbors(current[0], current[1]):\r\n                tentative_g_score = g_score[current] + self.distance(current, neighbor)\r\n\r\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\r\n                    came_from[neighbor] = current\r\n                    g_score[neighbor] = tentative_g_score\r\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)\r\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\r\n\r\n        return []  # No path found\r\n\r\n    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\r\n        """Calculate heuristic distance (Euclidean)"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\r\n        """Calculate distance between two adjacent cells"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def get_neighbors(self, x: int, y: int) -> List[Tuple[int, int]]:\r\n        """Get valid neighbors of a cell"""\r\n        neighbors = []\r\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\r\n            nx, ny = x + dx, y + dy\r\n            if self.is_valid_cell(nx, ny):\r\n                neighbors.append((nx, ny))\r\n        return neighbors\r\n\r\n    def is_valid_cell(self, x: int, y: int) -> bool:\r\n        """Check if cell is valid and not occupied"""\r\n        if x < 0 or x >= self.width or y < 0 or y >= self.height:\r\n            return False\r\n        # Assume grid_map contains occupancy probabilities (0.0 = free, 1.0 = occupied)\r\n        return self.grid_map[y, x] < 0.7  # Threshold for considering cell as free\r\n\r\n    def reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:\r\n        """Reconstruct path from came_from dictionary"""\r\n        path = [current]\r\n        while current in came_from:\r\n            current = came_from[current]\r\n            path.append(current)\r\n        path.reverse()\r\n        return path\n'})}),"\n",(0,a.jsx)(e.h3,{id:"832-dijkstras-algorithm",children:"8.3.2 Dijkstra's Algorithm"}),"\n",(0,a.jsx)(e.p,{children:"Dijkstra's algorithm finds the shortest path without using heuristic information:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class DijkstraPlanner:\r\n    def __init__(self, grid_map):\r\n        self.grid_map = grid_map\r\n        self.height, self.width = grid_map.shape\r\n\r\n    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\r\n        """Plan path using Dijkstra\'s algorithm"""\r\n        if not self.is_valid_cell(start[0], start[1]) or not self.is_valid_cell(goal[0], goal[1]):\r\n            return []\r\n\r\n        # Initialize data structures\r\n        open_set = [(0, start)]  # (distance, position)\r\n        came_from = {}\r\n        distances = {start: 0}\r\n\r\n        while open_set:\r\n            current_dist, current = heapq.heappop(open_set)\r\n\r\n            if current == goal:\r\n                return self.reconstruct_path(came_from, current)\r\n\r\n            # Explore neighbors\r\n            for neighbor in self.get_neighbors(current[0], current[1]):\r\n                new_dist = distances[current] + self.distance(current, neighbor)\r\n\r\n                if neighbor not in distances or new_dist < distances[neighbor]:\r\n                    came_from[neighbor] = current\r\n                    distances[neighbor] = new_dist\r\n                    heapq.heappush(open_set, (new_dist, neighbor))\r\n\r\n        return []  # No path found\r\n\r\n    def distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\r\n        """Calculate distance between two adjacent cells"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def get_neighbors(self, x: int, y: int) -> List[Tuple[int, int]]:\r\n        """Get valid neighbors of a cell"""\r\n        neighbors = []\r\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\r\n            nx, ny = x + dx, y + dy\r\n            if self.is_valid_cell(nx, ny):\r\n                neighbors.append((nx, ny))\r\n        return neighbors\r\n\r\n    def is_valid_cell(self, x: int, y: int) -> bool:\r\n        """Check if cell is valid and not occupied"""\r\n        if x < 0 or x >= self.width or y < 0 or y >= self.height:\r\n            return False\r\n        return self.grid_map[y, x] < 0.7\r\n\r\n    def reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:\r\n        """Reconstruct path from came_from dictionary"""\r\n        path = [current]\r\n        while current in came_from:\r\n            current = came_from[current]\r\n            path.append(current)\r\n        path.reverse()\r\n        return path\n'})}),"\n",(0,a.jsx)(e.h3,{id:"833-rrt-rapidly-exploring-random-trees",children:"8.3.3 RRT (Rapidly-exploring Random Trees)"}),"\n",(0,a.jsx)(e.p,{children:"RRT is a sampling-based algorithm suitable for high-dimensional configuration spaces:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class RRTPlanner:\r\n    def __init__(self, grid_map, step_size=1.0):\r\n        self.grid_map = grid_map\r\n        self.height, self.width = grid_map.shape\r\n        self.step_size = step_size\r\n\r\n    def plan_path(self, start: Tuple[float, float], goal: Tuple[float, float], max_iterations=10000) -> List[Tuple[float, float]]:\r\n        """Plan path using RRT algorithm"""\r\n        tree = [start]\r\n        parent = {start: None}\r\n\r\n        for _ in range(max_iterations):\r\n            # Sample random point\r\n            rand_point = self.sample_free_space()\r\n\r\n            # Find nearest point in tree\r\n            nearest = self.nearest_node(tree, rand_point)\r\n\r\n            # Create new point in direction of random point\r\n            new_point = self.steer(nearest, rand_point)\r\n\r\n            # Check if path is collision-free\r\n            if self.is_collision_free(nearest, new_point):\r\n                tree.append(new_point)\r\n                parent[new_point] = nearest\r\n\r\n                # Check if we can connect to goal\r\n                if self.distance(new_point, goal) < self.step_size:\r\n                    if self.is_collision_free(new_point, goal):\r\n                        parent[goal] = new_point\r\n                        return self.reconstruct_path_rrt(parent, start, goal)\r\n\r\n        return []  # No path found\r\n\r\n    def sample_free_space(self) -> Tuple[float, float]:\r\n        """Sample a random point in free space"""\r\n        while True:\r\n            x = np.random.uniform(0, self.width)\r\n            y = np.random.uniform(0, self.height)\r\n\r\n            grid_x, grid_y = int(x), int(y)\r\n            if (0 <= grid_x < self.width and 0 <= grid_y < self.height and\r\n                self.grid_map[grid_y, grid_x] < 0.7):\r\n                return (x, y)\r\n\r\n    def nearest_node(self, tree: List[Tuple[float, float]], point: Tuple[float, float]) -> Tuple[float, float]:\r\n        """Find the nearest node in the tree to the given point"""\r\n        nearest = tree[0]\r\n        min_dist = self.distance(nearest, point)\r\n\r\n        for node in tree[1:]:\r\n            dist = self.distance(node, point)\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n                nearest = node\r\n\r\n        return nearest\r\n\r\n    def steer(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> Tuple[float, float]:\r\n        """Create a new node in the direction from from_node to to_node"""\r\n        dist = self.distance(from_node, to_node)\r\n        if dist <= self.step_size:\r\n            return to_node\r\n\r\n        # Create point in direction of to_node at step_size distance\r\n        direction = ((to_node[0] - from_node[0]) / dist,\r\n                     (to_node[1] - from_node[1]) / dist)\r\n        new_x = from_node[0] + self.step_size * direction[0]\r\n        new_y = from_node[1] + self.step_size * direction[1]\r\n\r\n        return (new_x, new_y)\r\n\r\n    def is_collision_free(self, from_node: Tuple[float, float], to_node: Tuple[float, float]) -> bool:\r\n        """Check if the path between two nodes is collision-free"""\r\n        # Simple check: if both endpoints are free, assume path is free\r\n        # In practice, you\'d check multiple points along the path\r\n        x1, y1 = from_node\r\n        x2, y2 = to_node\r\n\r\n        grid_x1, grid_y1 = int(x1), int(y1)\r\n        grid_x2, grid_y2 = int(x2), int(y2)\r\n\r\n        # Check both endpoints\r\n        if (0 <= grid_x1 < self.width and 0 <= grid_y1 < self.height and\r\n            self.grid_map[grid_y1, grid_x1] >= 0.7):\r\n            return False\r\n\r\n        if (0 <= grid_x2 < self.width and 0 <= grid_y2 < self.height and\r\n            self.grid_map[grid_y2, grid_x2] >= 0.7):\r\n            return False\r\n\r\n        # For a more thorough check, sample points along the line\r\n        steps = int(self.distance(from_node, to_node) / 0.5)  # Check every 0.5m\r\n        for i in range(1, steps):\r\n            t = i / steps\r\n            x = x1 + t * (x2 - x1)\r\n            y = y1 + t * (y2 - y1)\r\n\r\n            grid_x, grid_y = int(x), int(y)\r\n            if (0 <= grid_x < self.width and 0 <= grid_y < self.height and\r\n                self.grid_map[grid_y, grid_x] >= 0.7):\r\n                return False\r\n\r\n        return True\r\n\r\n    def distance(self, pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:\r\n        """Calculate Euclidean distance between two points"""\r\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\r\n\r\n    def reconstruct_path_rrt(self, parent: dict, start: Tuple[float, float], goal: Tuple[float, float]) -> List[Tuple[float, float]]:\r\n        """Reconstruct path from RRT tree"""\r\n        path = [goal]\r\n        current = goal\r\n\r\n        while current != start:\r\n            if current not in parent:\r\n                return []  # No path found\r\n            current = parent[current]\r\n            path.append(current)\r\n\r\n        path.reverse()\r\n        return path\n'})}),"\n",(0,a.jsx)(e.h2,{id:"84-ros-2-navigation-integration",children:"8.4 ROS 2 Navigation Integration"}),"\n",(0,a.jsx)(e.h3,{id:"841-navigation2-stack-components",children:"8.4.1 Navigation2 Stack Components"}),"\n",(0,a.jsx)(e.p,{children:"The Navigation2 stack provides a comprehensive navigation system for ROS 2:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\nfrom nav_msgs.msg import OccupancyGrid, Path\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom tf2_ros import TransformListener, Buffer\r\nfrom tf2_geometry_msgs import do_transform_pose\r\nimport tf2_ros\r\nimport numpy as np\r\nimport math\r\n\r\nclass NavigationNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'navigation_node\')\r\n\r\n        # Initialize navigation components\r\n        self.current_pose = None\r\n        self.goal_pose = None\r\n        self.map = None\r\n        self.path = None\r\n        self.laser_scan = None\r\n\r\n        # TF listener for transforms\r\n        self.tf_buffer = tf2_ros.Buffer()\r\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\r\n\r\n        # Setup subscribers\r\n        self.pose_sub = self.create_subscription(\r\n            PoseStamped, \'/amcl_pose\', self.pose_callback, 10\r\n        )\r\n\r\n        self.map_sub = self.create_subscription(\r\n            OccupancyGrid, \'/map\', self.map_callback, 10\r\n        )\r\n\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, \'/scan\', self.scan_callback, 10\r\n        )\r\n\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped, \'/move_base_simple/goal\', self.goal_callback, 10\r\n        )\r\n\r\n        # Setup publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.path_pub = self.create_publisher(Path, \'/plan\', 10)\r\n\r\n        # Setup navigation timer\r\n        self.nav_timer = self.create_timer(0.1, self.navigation_loop)\r\n\r\n        # Path planner\r\n        self.path_planner = None\r\n        self.local_planner = LocalPlanner()\r\n\r\n        self.get_logger().info("Navigation node initialized")\r\n\r\n    def pose_callback(self, msg):\r\n        """Update current robot pose"""\r\n        self.current_pose = msg.pose\r\n\r\n    def map_callback(self, msg):\r\n        """Update map data"""\r\n        self.map = msg\r\n        # Convert to numpy array for path planning\r\n        self.map_array = np.array(msg.data).reshape(msg.info.height, msg.info.width)\r\n\r\n    def scan_callback(self, msg):\r\n        """Update laser scan data"""\r\n        self.laser_scan = msg\r\n\r\n    def goal_callback(self, msg):\r\n        """Set navigation goal"""\r\n        self.goal_pose = msg.pose\r\n        self.get_logger().info(f"New goal set: ({msg.pose.position.x:.2f}, {msg.pose.position.y:.2f})")\r\n\r\n        # Plan path to goal\r\n        if self.current_pose and self.map:\r\n            self.plan_path()\r\n\r\n    def plan_path(self):\r\n        """Plan path from current position to goal"""\r\n        if not self.current_pose or not self.goal_pose or self.map is None:\r\n            return\r\n\r\n        # Convert poses to grid coordinates\r\n        start_grid = self.world_to_grid(\r\n            self.current_pose.position.x,\r\n            self.current_pose.position.y\r\n        )\r\n        goal_grid = self.world_to_grid(\r\n            self.goal_pose.position.x,\r\n            self.goal_pose.position.y\r\n        )\r\n\r\n        # Create path planner\r\n        self.path_planner = AStarPlanner(self.map_array)\r\n\r\n        # Plan path\r\n        path_grid = self.path_planner.plan_path(start_grid, goal_grid)\r\n\r\n        if path_grid:\r\n            # Convert grid path back to world coordinates\r\n            self.path = []\r\n            for grid_x, grid_y in path_grid:\r\n                world_x, world_y = self.grid_to_world(grid_x, grid_y)\r\n                pose_stamped = PoseStamped()\r\n                pose_stamped.pose.position.x = world_x\r\n                pose_stamped.pose.position.y = world_y\r\n                pose_stamped.pose.orientation.w = 1.0  # No rotation\r\n                self.path.append(pose_stamped)\r\n\r\n            # Publish path\r\n            path_msg = Path()\r\n            path_msg.poses = self.path\r\n            path_msg.header.frame_id = "map"\r\n            path_msg.header.stamp = self.get_clock().now().to_msg()\r\n            self.path_pub.publish(path_msg)\r\n\r\n            self.get_logger().info(f"Path planned with {len(self.path)} waypoints")\r\n        else:\r\n            self.get_logger().warn("No path found to goal")\r\n\r\n    def navigation_loop(self):\r\n        """Main navigation control loop"""\r\n        if self.current_pose and self.path and self.path:\r\n            # Follow the path using local planner\r\n            cmd_vel = self.local_planner.compute_velocity(\r\n                self.current_pose,\r\n                self.path,\r\n                self.laser_scan\r\n            )\r\n            self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n    def world_to_grid(self, x, y):\r\n        """Convert world coordinates to grid coordinates"""\r\n        if self.map is None:\r\n            return (0, 0)\r\n\r\n        grid_x = int((x - self.map.info.origin.position.x) / self.map.info.resolution)\r\n        grid_y = int((y - self.map.info.origin.position.y) / self.map.info.resolution)\r\n        return (grid_x, grid_y)\r\n\r\n    def grid_to_world(self, grid_x, grid_y):\r\n        """Convert grid coordinates to world coordinates"""\r\n        if self.map is None:\r\n            return (0, 0)\r\n\r\n        x = grid_x * self.map.info.resolution + self.map.info.origin.position.x\r\n        y = grid_y * self.map.info.resolution + self.map.info.origin.position.y\r\n        return (x, y)\r\n\r\n\r\nclass LocalPlanner:\r\n    """Local planner for following global path and obstacle avoidance"""\r\n    def __init__(self):\r\n        self.lookahead_distance = 1.0\r\n        self.max_linear_speed = 0.5\r\n        self.max_angular_speed = 1.0\r\n\r\n    def compute_velocity(self, current_pose, global_path, laser_scan):\r\n        """Compute velocity command to follow path and avoid obstacles"""\r\n        cmd_vel = Twist()\r\n\r\n        if not global_path:\r\n            return cmd_vel\r\n\r\n        # Find closest point on path\r\n        closest_idx = self.find_closest_waypoint(current_pose, global_path)\r\n\r\n        # Find point to follow (lookahead)\r\n        follow_idx = self.find_lookahead_point(current_pose, global_path, closest_idx)\r\n\r\n        if follow_idx is not None:\r\n            # Calculate desired direction\r\n            target_x = global_path[follow_idx].pose.position.x\r\n            target_y = global_path[follow_idx].pose.position.y\r\n\r\n            current_x = current_pose.position.x\r\n            current_y = current_pose.position.y\r\n\r\n            dx = target_x - current_x\r\n            dy = target_y - current_y\r\n\r\n            # Calculate distance to target\r\n            distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n            # Calculate heading to target\r\n            desired_heading = math.atan2(dy, dx)\r\n\r\n            # Get current heading from quaternion\r\n            current_heading = self.get_yaw_from_quaternion(current_pose.orientation)\r\n\r\n            # Calculate heading error\r\n            heading_error = desired_heading - current_heading\r\n            # Normalize angle to [-pi, pi]\r\n            while heading_error > math.pi:\r\n                heading_error -= 2 * math.pi\r\n            while heading_error < -math.pi:\r\n                heading_error += 2 * math.pi\r\n\r\n            # Simple proportional controller\r\n            cmd_vel.linear.x = min(self.max_linear_speed * 0.5, max(0.1, distance * 0.5))\r\n            cmd_vel.angular.z = max(-self.max_angular_speed, min(self.max_angular_speed, heading_error * 2.0))\r\n\r\n            # Check for obstacles using laser scan\r\n            if laser_scan and self.is_obstacle_ahead(laser_scan):\r\n                cmd_vel.linear.x = 0.0\r\n                cmd_vel.angular.z *= 0.5  # Reduce turning when stopping\r\n\r\n        return cmd_vel\r\n\r\n    def find_closest_waypoint(self, current_pose, path):\r\n        """Find the closest waypoint on the path"""\r\n        min_dist = float(\'inf\')\r\n        closest_idx = 0\r\n\r\n        for i, pose_stamped in enumerate(path):\r\n            dx = pose_stamped.pose.position.x - current_pose.position.x\r\n            dy = pose_stamped.pose.position.y - current_pose.position.y\r\n            dist = math.sqrt(dx*dx + dy*dy)\r\n\r\n            if dist < min_dist:\r\n                min_dist = dist\r\n                closest_idx = i\r\n\r\n        return closest_idx\r\n\r\n    def find_lookahead_point(self, current_pose, path, start_idx):\r\n        """Find the point on the path that is the lookahead distance away"""\r\n        current_x = current_pose.position.x\r\n        current_y = current_pose.position.y\r\n\r\n        for i in range(start_idx, len(path)):\r\n            dx = path[i].pose.position.x - current_x\r\n            dy = path[i].pose.position.y - current_y\r\n            dist = math.sqrt(dx*dx + dy*dy)\r\n\r\n            if dist >= self.lookahead_distance:\r\n                return i\r\n\r\n        # If no point is far enough, return the last point\r\n        return len(path) - 1 if path else None\r\n\r\n    def get_yaw_from_quaternion(self, quat):\r\n        """Extract yaw angle from quaternion"""\r\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\r\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def is_obstacle_ahead(self, laser_scan):\r\n        """Check if there\'s an obstacle directly ahead using laser scan"""\r\n        if not laser_scan:\r\n            return False\r\n\r\n        # Check the front 30 degrees of the laser scan\r\n        num_ranges = len(laser_scan.ranges)\r\n        front_start = num_ranges // 2 - num_ranges // 24  # -15 degrees\r\n        front_end = num_ranges // 2 + num_ranges // 24    # +15 degrees\r\n\r\n        if front_start < 0:\r\n            front_start = 0\r\n        if front_end >= num_ranges:\r\n            front_end = num_ranges - 1\r\n\r\n        # Check for obstacles within 1 meter in front\r\n        for i in range(front_start, front_end + 1):\r\n            if not math.isnan(laser_scan.ranges[i]) and laser_scan.ranges[i] < 1.0:\r\n                return True\r\n\r\n        return False\n'})}),"\n",(0,a.jsx)(e.h2,{id:"85-motion-planning-and-trajectory-generation",children:"8.5 Motion Planning and Trajectory Generation"}),"\n",(0,a.jsx)(e.h3,{id:"851-trajectory-optimization",children:"8.5.1 Trajectory Optimization"}),"\n",(0,a.jsx)(e.p,{children:"Motion planning generates dynamically feasible trajectories:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class TrajectoryOptimizer:\r\n    def __init__(self):\r\n        self.max_velocity = 1.0\r\n        self.max_acceleration = 0.5\r\n        self.dt = 0.1  # Time step\r\n\r\n    def generate_trajectory(self, path, start_velocity=(0.0, 0.0)):\r\n        """Generate smooth trajectory following the path"""\r\n        if len(path) < 2:\r\n            return []\r\n\r\n        trajectory = []\r\n        current_vel = start_velocity\r\n\r\n        for i in range(len(path) - 1):\r\n            start_pos = (path[i].pose.position.x, path[i].pose.position.y)\r\n            end_pos = (path[i+1].pose.position.x, path[i+1].pose.position.y)\r\n\r\n            # Calculate distance and direction\r\n            dx = end_pos[0] - start_pos[0]\r\n            dy = end_pos[1] - start_pos[1]\r\n            distance = math.sqrt(dx*dx + dy*dy)\r\n\r\n            if distance > 0.01:  # Avoid division by zero\r\n                direction = (dx/distance, dy/distance)\r\n\r\n                # Calculate required acceleration to reach target velocity\r\n                target_speed = min(self.max_velocity, distance / self.dt)\r\n                required_accel = (target_speed - current_vel[0]) / self.dt\r\n\r\n                # Limit acceleration\r\n                if abs(required_accel) > self.max_acceleration:\r\n                    required_accel = math.copysign(self.max_acceleration, required_accel)\r\n\r\n                # Update velocity\r\n                new_vel_x = current_vel[0] + required_accel * self.dt\r\n                new_vel_x = max(-self.max_velocity, min(self.max_velocity, new_vel_x))\r\n\r\n                # Calculate position update\r\n                new_pos_x = start_pos[0] + new_vel_x * self.dt * direction[0]\r\n                new_pos_y = start_pos[1] + new_vel_x * self.dt * direction[1]\r\n\r\n                # Create trajectory point\r\n                traj_point = PoseStamped()\r\n                traj_point.pose.position.x = new_pos_x\r\n                traj_point.pose.position.y = new_pos_y\r\n                traj_point.pose.position.z = 0.0\r\n\r\n                # Calculate orientation\r\n                traj_point.pose.orientation.z = math.sin(math.atan2(dy, dx) / 2)\r\n                traj_point.pose.orientation.w = math.cos(math.atan2(dy, dx) / 2)\r\n\r\n                trajectory.append(traj_point)\r\n                current_vel = (new_vel_x, 0.0)\r\n\r\n        return trajectory\r\n\r\n    def smooth_path(self, path, alpha=0.1, beta=0.3, tolerance=0.001):\r\n        """Smooth path using gradient descent optimization"""\r\n        if len(path) < 3:\r\n            return path\r\n\r\n        # Convert path to numpy arrays for easier manipulation\r\n        orig_path = np.array([[p.pose.position.x, p.pose.position.y] for p in path])\r\n        smooth_path = orig_path.copy()\r\n\r\n        change = tolerance\r\n        while change >= tolerance:\r\n            change = 0.0\r\n            for i in range(1, len(orig_path) - 1):\r\n                for j in range(2):  # x and y coordinates\r\n                    aux = smooth_path[i, j]\r\n                    # Gradient descent step\r\n                    smooth_path[i, j] += alpha * (orig_path[i, j] - smooth_path[i, j])\r\n                    smooth_path[i, j] += beta * (smooth_path[i-1, j] + smooth_path[i+1, j] - 2.0 * smooth_path[i, j])\r\n                    change += abs(aux - smooth_path[i, j])\r\n\r\n        # Convert back to PoseStamped format\r\n        smoothed_path = []\r\n        for point in smooth_path:\r\n            pose_stamped = PoseStamped()\r\n            pose_stamped.pose.position.x = point[0]\r\n            pose_stamped.pose.position.y = point[1]\r\n            pose_stamped.pose.position.z = 0.0\r\n            pose_stamped.pose.orientation.w = 1.0\r\n            smoothed_path.append(pose_stamped)\r\n\r\n        return smoothed_path\n'})}),"\n",(0,a.jsx)(e.h3,{id:"852-dynamic-window-approach-dwa",children:"8.5.2 Dynamic Window Approach (DWA)"}),"\n",(0,a.jsx)(e.p,{children:"DWA is a local path planning method that considers robot dynamics:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class DynamicWindowApproach:\r\n    def __init__(self):\r\n        # Robot parameters\r\n        self.max_speed = 0.5  # m/s\r\n        self.min_speed = 0.0  # m/s\r\n        self.max_yaw_rate = 40.0 * math.pi / 180.0  # rad/s\r\n        self.max_accel = 0.5  # m/ss\r\n        self.max_delta_yaw_rate = 40.0 * math.pi / 180.0  # rad/ss\r\n        self.dt = 0.1  # [s]\r\n        self.predict_time = 3.0  # [s]\r\n        self.to_goal_cost_gain = 0.15\r\n        self.speed_cost_gain = 1.0\r\n        self.obstacle_cost_gain = 1.0\r\n\r\n    def plan_local_path(self, current_state, goal, obstacles):\r\n        """Plan local path using Dynamic Window Approach"""\r\n        # Generate dynamic window\r\n        u, predicted_trajectory = self.calc_dynamic_window(current_state)\r\n\r\n        min_cost = float(\'inf\')\r\n        best_u = [0.0, 0.0]\r\n        best_trajectory = []\r\n\r\n        # Evaluate all possible velocities\r\n        for vel in u:\r\n            trajectory = self.predict_trajectory(current_state, vel[0], vel[1])\r\n\r\n            # Calculate costs\r\n            to_goal_cost = self.calc_to_goal_cost(trajectory, goal)\r\n            speed_cost = self.calc_speed_cost(trajectory)\r\n            obstacle_cost = self.calc_obstacle_cost(trajectory, obstacles)\r\n\r\n            # Total cost\r\n            final_cost = (self.to_goal_cost_gain * to_goal_cost +\r\n                         self.speed_cost_gain * speed_cost +\r\n                         self.obstacle_cost_gain * obstacle_cost)\r\n\r\n            # Find minimum cost trajectory\r\n            if min_cost >= final_cost:\r\n                min_cost = final_cost\r\n                best_u = [vel[0], vel[1]]\r\n                best_trajectory = trajectory\r\n\r\n        return best_u, best_trajectory\r\n\r\n    def calc_dynamic_window(self, current_state):\r\n        """Calculate dynamic window"""\r\n        # Dynamic window from robot specification\r\n        Vs = [self.min_speed, self.max_speed,\r\n              -self.max_yaw_rate, self.max_yaw_rate]\r\n\r\n        # Dynamic window from motion model\r\n        Vd = [current_state[3] - self.max_accel * self.dt,\r\n              current_state[3] + self.max_accel * self.dt,\r\n              current_state[4] - self.max_delta_yaw_rate * self.dt,\r\n              current_state[4] + self.max_delta_yaw_rate * self.dt]\r\n\r\n        # Find section between Vs and Vd\r\n        dw = [max(Vs[0], Vd[0]), min(Vs[1], Vd[1]),\r\n              max(Vs[2], Vd[2]), min(Vs[3], Vd[3])]\r\n\r\n        return dw, []\r\n\r\n    def predict_trajectory(self, current_state, v, y):\r\n        """Predict trajectory with given velocity"""\r\n        x = current_state[:]\r\n        trajectory = [x[:]]\r\n\r\n        time = 0\r\n        while time <= self.predict_time:\r\n            x = self.motion(x, [v, y])\r\n            trajectory.append(x[:])\r\n            time += self.dt\r\n\r\n        return trajectory\r\n\r\n    def motion(self, state, vel):\r\n        """Motion model"""\r\n        state[0] += vel[0] * math.cos(state[2]) * self.dt\r\n        state[1] += vel[0] * math.sin(state[2]) * self.dt\r\n        state[2] += vel[1] * self.dt\r\n        state[3] = vel[0]\r\n        state[4] = vel[1]\r\n\r\n        return state\r\n\r\n    def calc_to_goal_cost(self, trajectory, goal):\r\n        """Calculate cost to goal"""\r\n        dx = goal[0] - trajectory[-1][0]\r\n        dy = goal[1] - trajectory[-1][1]\r\n        error_angle = math.atan2(dy, dx)\r\n        cost_angle = error_angle - trajectory[-1][2]\r\n        cost = abs(math.atan2(math.sin(cost_angle), math.cos(cost_angle)))\r\n\r\n        return cost\r\n\r\n    def calc_speed_cost(self, trajectory):\r\n        """Calculate speed cost"""\r\n        # Higher speeds are preferred\r\n        return abs(trajectory[-1][3])  # Velocity at the end of trajectory\r\n\r\n    def calc_obstacle_cost(self, trajectory, obstacles):\r\n        """Calculate obstacle cost"""\r\n        min_dist = float(\'inf\')\r\n        for i in range(len(trajectory)):\r\n            for j in range(len(obstacles)):\r\n                dist = math.sqrt((trajectory[i][0] - obstacles[j][0])**2 +\r\n                                (trajectory[i][1] - obstacles[j][1])**2)\r\n                if dist <= min_dist:\r\n                    min_dist = dist\r\n\r\n        # If min_dist is infinity, it means no obstacle is in the trajectory\r\n        if min_dist == float(\'inf\'):\r\n            return 0\r\n\r\n        # Cost is inversely proportional to distance\r\n        return 1.0 / min_dist if min_dist != 0 else float(\'inf\')\n'})}),"\n",(0,a.jsx)(e.h2,{id:"86-behavior-based-navigation",children:"8.6 Behavior-Based Navigation"}),"\n",(0,a.jsx)(e.h3,{id:"861-reactive-navigation-behaviors",children:"8.6.1 Reactive Navigation Behaviors"}),"\n",(0,a.jsx)(e.p,{children:"Behavior-based navigation decomposes navigation into simple, reactive behaviors:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class BehaviorBasedNavigator:\r\n    def __init__(self):\r\n        self.behaviors = [\r\n            self.go_to_goal_behavior,\r\n            self.avoid_obstacles_behavior,\r\n            self.follow_walls_behavior\r\n        ]\r\n        self.current_behavior = 0\r\n\r\n    def go_to_goal_behavior(self, current_pose, goal_pose, sensor_data):\r\n        """Simple go-to-goal behavior"""\r\n        dx = goal_pose.position.x - current_pose.position.x\r\n        dy = goal_pose.position.y - current_pose.position.y\r\n\r\n        distance = math.sqrt(dx*dx + dy*dy)\r\n        angle_to_goal = math.atan2(dy, dx)\r\n\r\n        current_yaw = self.get_yaw_from_quaternion(current_pose.orientation)\r\n        angle_error = angle_to_goal - current_yaw\r\n\r\n        # Normalize angle\r\n        while angle_error > math.pi:\r\n            angle_error -= 2 * math.pi\r\n        while angle_error < -math.pi:\r\n            angle_error += 2 * math.pi\r\n\r\n        # Return velocity command\r\n        linear_vel = min(0.5, distance * 0.5) if distance > 0.2 else 0.0\r\n        angular_vel = max(-1.0, min(1.0, angle_error * 2.0))\r\n\r\n        return linear_vel, angular_vel\r\n\r\n    def avoid_obstacles_behavior(self, current_pose, goal_pose, sensor_data):\r\n        """Obstacle avoidance behavior using sensor data"""\r\n        if not sensor_data or len(sensor_data.ranges) == 0:\r\n            return 0.0, 0.0\r\n\r\n        # Check for obstacles in front\r\n        num_ranges = len(sensor_data.ranges)\r\n        front_start = num_ranges // 2 - num_ranges // 8  # -22.5 degrees\r\n        front_end = num_ranges // 2 + num_ranges // 8    # +22.5 degrees\r\n\r\n        min_range = min(sensor_data.ranges[front_start:front_end]) if front_start < front_end else float(\'inf\')\r\n\r\n        if min_range < 0.5:  # Obstacle too close\r\n            # Turn away from obstacle\r\n            left_clear = min(sensor_data.ranges[num_ranges//2:num_ranges*3//4]) > 1.0\r\n            right_clear = min(sensor_data.ranges[num_ranges//4:num_ranges//2]) > 1.0\r\n\r\n            if left_clear and not right_clear:\r\n                return 0.0, 0.5  # Turn left\r\n            elif right_clear and not left_clear:\r\n                return 0.0, -0.5  # Turn right\r\n            else:\r\n                return 0.0, 0.5  # Default to turning left\r\n\r\n        # If no obstacle ahead, move forward\r\n        return 0.3, 0.0\r\n\r\n    def follow_walls_behavior(self, current_pose, goal_pose, sensor_data):\r\n        """Wall following behavior"""\r\n        if not sensor_data or len(sensor_data.ranges) == 0:\r\n            return 0.0, 0.0\r\n\r\n        # Use sensor values from different directions\r\n        left_range = sensor_data.ranges[len(sensor_data.ranges) * 3 // 4]  # 135 degrees\r\n        front_range = sensor_data.ranges[len(sensor_data.ranges) // 2]     # 0 degrees\r\n        right_range = sensor_data.ranges[len(sensor_data.ranges) // 4]     # -45 degrees\r\n\r\n        # Simple wall following algorithm\r\n        target_distance = 0.5  # Desired distance from wall\r\n\r\n        if front_range > 1.0:  # Path is clear ahead\r\n            if left_range > target_distance * 1.5:  # Too far from left wall\r\n                return 0.3, -0.3  # Turn left toward wall\r\n            elif left_range < target_distance * 0.7:  # Too close to left wall\r\n                return 0.3, 0.3   # Turn right away from wall\r\n            else:  # Good distance from wall\r\n                return 0.3, 0.0   # Move forward\r\n        else:  # Obstacle ahead\r\n            return 0.0, 0.5       # Turn away from obstacle\r\n\r\n    def get_yaw_from_quaternion(self, quat):\r\n        """Extract yaw from quaternion"""\r\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\r\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\r\n\r\n    def select_behavior(self, current_pose, goal_pose, sensor_data):\r\n        """Select the most appropriate behavior based on the situation"""\r\n        # This is a simple priority-based selection\r\n        # In practice, you might use a more sophisticated arbitration mechanism\r\n\r\n        # Check for immediate obstacles\r\n        if sensor_data and len(sensor_data.ranges) > 0:\r\n            front_ranges = sensor_data.ranges[len(sensor_data.ranges)//2 - len(sensor_data.ranges)//16 :\r\n                                            len(sensor_data.ranges)//2 + len(sensor_data.ranges)//16]\r\n            min_front_range = min(front_ranges) if front_ranges else float(\'inf\')\r\n\r\n            if min_front_range < 0.4:  # Emergency obstacle avoidance\r\n                return self.avoid_obstacles_behavior(current_pose, goal_pose, sensor_data)\r\n\r\n        # For normal navigation, use go-to-goal behavior\r\n        return self.go_to_goal_behavior(current_pose, goal_pose, sensor_data)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"87-integration-with-physical-ai-systems",children:"8.7 Integration with Physical AI Systems"}),"\n",(0,a.jsx)(e.p,{children:"Navigation systems in Physical AI must consider the interaction between perception, planning, and control:"}),"\n",(0,a.jsx)(e.h3,{id:"871-perception-action-integration",children:"8.7.1 Perception-Action Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class IntegratedNavigationSystem(Node):\r\n    def __init__(self):\r\n        super().__init__(\'integrated_navigation_system\')\r\n\r\n        # Initialize components\r\n        self.perception_module = PerceptionModule()\r\n        self.mapping_module = OccupancyGridMap(100, 100, 0.1)\r\n        self.path_planner = AStarPlanner(None)\r\n        self.local_planner = LocalPlanner()\r\n        self.behavior_navigator = BehaviorBasedNavigator()\r\n\r\n        # Setup ROS 2 interface\r\n        self.setup_ros_interface()\r\n\r\n    def setup_ros_interface(self):\r\n        """Setup ROS 2 publishers and subscribers"""\r\n        # Subscribe to sensor data\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan, \'/scan\', self.laser_callback, 10\r\n        )\r\n\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, \'/odom\', self.odom_callback, 10\r\n        )\r\n\r\n        # Publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.map_pub = self.create_publisher(OccupancyGrid, \'/map\', 10)\r\n\r\n        # Setup main navigation timer\r\n        self.nav_timer = self.create_timer(0.1, self.integrated_navigation_loop)\r\n\r\n    def integrated_navigation_loop(self):\r\n        """Main loop integrating perception, mapping, and navigation"""\r\n        # Update map with latest sensor data\r\n        if self.latest_scan and self.current_odom:\r\n            robot_pose = self.odom_to_pose(self.current_odom)\r\n            self.mapping_module.update_with_laser_scan(\r\n                (robot_pose.position.x, robot_pose.position.y, self.get_yaw_from_quaternion(robot_pose.orientation)),\r\n                self.latest_scan.ranges,\r\n                self.generate_scan_angles(self.latest_scan)\r\n            )\r\n\r\n            # Update path planner with new map\r\n            self.path_planner.grid_map = self.mapping_module.grid\r\n\r\n            # Perform navigation\r\n            if self.navigation_goal:\r\n                self.execute_navigation(robot_pose)\r\n\r\n    def execute_navigation(self, robot_pose):\r\n        """Execute navigation with integrated perception and planning"""\r\n        # Use behavior-based navigation as fallback\r\n        linear_vel, angular_vel = self.behavior_navigator.select_behavior(\r\n            robot_pose, self.navigation_goal, self.latest_scan\r\n        )\r\n\r\n        # Create and publish velocity command\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = linear_vel\r\n        cmd_vel.angular.z = angular_vel\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n    def laser_callback(self, msg):\r\n        """Handle laser scan data"""\r\n        self.latest_scan = msg\r\n\r\n    def odom_callback(self, msg):\r\n        """Handle odometry data"""\r\n        self.current_odom = msg\r\n\r\n    def odom_to_pose(self, odom_msg):\r\n        """Convert odometry message to pose"""\r\n        pose_stamped = PoseStamped()\r\n        pose_stamped.pose = odom_msg.pose.pose\r\n        return pose_stamped.pose\n'})}),"\n",(0,a.jsx)(e.h2,{id:"88-performance-evaluation-and-safety",children:"8.8 Performance Evaluation and Safety"}),"\n",(0,a.jsx)(e.h3,{id:"881-navigation-metrics",children:"8.8.1 Navigation Metrics"}),"\n",(0,a.jsx)(e.p,{children:"Evaluating navigation system performance:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class NavigationMetrics:\r\n    def __init__(self):\r\n        self.path_length = 0.0\r\n        self.execution_time = 0.0\r\n        self.success_count = 0\r\n        self.failure_count = 0\r\n        self.collision_count = 0\r\n        self.oscillation_count = 0\r\n\r\n    def calculate_path_efficiency(self, planned_path, optimal_path_length):\r\n        """Calculate path efficiency ratio"""\r\n        if optimal_path_length > 0:\r\n            return self.path_length / optimal_path_length\r\n        return 1.0  # If no optimal path, consider it 100% efficient\r\n\r\n    def calculate_success_rate(self):\r\n        """Calculate navigation success rate"""\r\n        total_attempts = self.success_count + self.failure_count\r\n        if total_attempts > 0:\r\n            return self.success_count / total_attempts\r\n        return 0.0\r\n\r\n    def evaluate_safety(self):\r\n        """Evaluate navigation safety based on collisions and oscillations"""\r\n        safety_score = 1.0\r\n        if self.collision_count > 0:\r\n            safety_score -= 0.5 * self.collision_count  # Heavy penalty for collisions\r\n        if self.oscillation_count > 0:\r\n            safety_score -= 0.1 * self.oscillation_count  # Lighter penalty for oscillations\r\n\r\n        return max(0.0, safety_score)  # Ensure non-negative score\n'})}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Mobile robot navigation and path planning form the foundation of autonomous robotic systems. The integration of localization, mapping, path planning, and motion control enables robots to operate effectively in complex environments. Modern navigation systems leverage both classical algorithms like A* and Dijkstra, as well as sampling-based methods like RRT for high-dimensional spaces. The ROS 2 Navigation2 stack provides a comprehensive framework for implementing these concepts. As Physical AI systems become more sophisticated, navigation algorithms must continue to evolve to handle dynamic environments, uncertainty, and safety-critical applications."})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>s});var t=r(6540);const a={},o=t.createContext(a);function i(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);