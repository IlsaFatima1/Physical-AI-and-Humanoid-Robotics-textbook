"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[47],{3358:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"ch08-navigation/exercises/chapter8-quiz","title":"Chapter 8 Quiz: Mobile Robot Navigation and Path Planning","description":"Multiple Choice Questions","source":"@site/ch08-navigation/exercises/chapter8-quiz.md","sourceDirName":"ch08-navigation/exercises","slug":"/ch08-navigation/exercises/chapter8-quiz","permalink":"/ch08-navigation/exercises/chapter8-quiz","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/ch08-navigation/exercises/chapter8-quiz.md","tags":[],"version":"current","frontMatter":{}}');var o=i(4848),t=i(8453);const s={},r="Chapter 8 Quiz: Mobile Robot Navigation and Path Planning",l={},c=[{value:"Multiple Choice Questions",id:"multiple-choice-questions",level:2},{value:"Practical Application Questions",id:"practical-application-questions",level:2},{value:"Code Analysis Questions",id:"code-analysis-questions",level:2},{value:"Conceptual Questions",id:"conceptual-questions",level:2},{value:"Answer Key",id:"answer-key",level:2},{value:"Multiple Choice Answers:",id:"multiple-choice-answers",level:3},{value:"Practical Application Answers:",id:"practical-application-answers",level:3},{value:"Code Analysis Answers:",id:"code-analysis-answers",level:3},{value:"Conceptual Answers:",id:"conceptual-answers",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-8-quiz-mobile-robot-navigation-and-path-planning",children:"Chapter 8 Quiz: Mobile Robot Navigation and Path Planning"})}),"\n",(0,o.jsx)(e.h2,{id:"multiple-choice-questions",children:"Multiple Choice Questions"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What does SLAM stand for in robotics navigation?\r\na) Simultaneous Localization and Mapping\r\nb) Systematic Localization and Mapping\r\nc) Simultaneous Learning and Mapping\r\nd) Systematic Learning and Autonomous Mapping"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Which path planning algorithm is guaranteed to find the shortest path?\r\na) Dijkstra's algorithm\r\nb) Greedy best-first search\r\nc) Rapidly-exploring Random Trees (RRT)\r\nd) Potential fields"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What is the main advantage of the A* algorithm over Dijkstra's algorithm?\r\na) A* is faster due to heuristic guidance\r\nb) A* finds paths in 3D space while Dijkstra only works in 2D\r\nc) A* can handle dynamic obstacles\r\nd) A* requires less memory"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"In the Dynamic Window Approach (DWA), what does the \"dynamic window\" represent?\r\na) A window in the robot's GUI\r\nb) The set of all possible velocities given robot dynamics\r\nc) A visual window for obstacle detection\r\nd) The robot's field of view"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What is the primary purpose of a costmap in ROS Navigation?\r\na) To store the robot's trajectory\r\nb) To represent obstacles and navigation costs in the environment\r\nc) To store sensor calibration data\r\nd) To maintain communication logs"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"practical-application-questions",children:"Practical Application Questions"}),"\n",(0,o.jsxs)(e.ol,{start:"6",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"You are developing a navigation system for a mobile robot in a dynamic warehouse environment. Design a complete navigation pipeline that includes:\r\na) Localization approach suitable for the environment\r\nb) Path planning strategy for static obstacles\r\nc) Local planning approach for dynamic obstacle avoidance\r\nd) Safety mechanisms to prevent collisions with moving objects"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Implement a hybrid navigation system that combines global path planning with local obstacle avoidance. Describe:\r\na) How the global and local planners interact\r\nb) The conditions that trigger replanning\r\nc) How to handle situations where local planner cannot find a way around obstacles\r\nd) Methods to ensure smooth transitions between global path following and local\u907fing"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Design a navigation system for a robot that must operate in GPS-denied environments. Consider:\r\na) Appropriate localization methods\r\nb) Mapping strategies for large-scale environments\r\nc) Path planning approaches that handle uncertainty\r\nd) Recovery strategies when navigation fails"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"code-analysis-questions",children:"Code Analysis Questions"}),"\n",(0,o.jsxs)(e.ol,{start:"9",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Analyze the following A* path planning code and identify potential issues:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"def a_star(grid, start, goal):\r\n    open_set = [start]\r\n    came_from = {}\r\n    g_score = {start: 0}\r\n    f_score = {start: heuristic(start, goal)}\r\n\r\n    while open_set:\r\n        current = min(open_set, key=lambda x: f_score.get(x, float('inf')))\r\n\r\n        if current == goal:\r\n            return reconstruct_path(came_from, current)\r\n\r\n        open_set.remove(current)\r\n\r\n        for neighbor in get_neighbors(current):\r\n            if neighbor in [0, 0, 0]:  # Check if neighbor is valid\r\n                continue\r\n\r\n            tentative_g_score = g_score[current] + distance(current, neighbor)\r\n\r\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\r\n                came_from[neighbor] = current\r\n                g_score[neighbor] = tentative_g_score\r\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\r\n                if neighbor not in open_set:\r\n                    open_set.append(neighbor)\r\n\r\n    return []  # No path found\n"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"The following navigation control code has potential problems. Identify and correct them:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"def navigate_to_goal(robot_pose, goal_pose, obstacles):\r\n    # Calculate angle to goal\r\n    dx = goal_pose.x - robot_pose.x\r\n    dy = goal_pose.y - robot_pose.y\r\n    angle_to_goal = math.atan2(dx, dy)  # Wrong order of arguments\r\n\r\n    # Get robot's current orientation\r\n    current_angle = robot_pose.theta\r\n\r\n    # Calculate error\r\n    angle_error = angle_to_goal - current_angle\r\n\r\n    # Set velocities\r\n    linear_vel = 1.0  # Constant speed regardless of distance\r\n    angular_vel = angle_error * 2.0\r\n\r\n    # Check for obstacles\r\n    for obs in obstacles:\r\n        dist_to_obs = math.sqrt((robot_pose.x - obs.x)**2 + (robot_pose.y - obs.y)**2)\r\n        if dist_to_obs < 1.0:  # Obstacle too close\r\n            linear_vel = 0.0\r\n            angular_vel = 1.0  # Always turn right regardless of obstacle position\r\n\r\n    return linear_vel, angular_vel\n"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"conceptual-questions",children:"Conceptual Questions"}),"\n",(0,o.jsxs)(e.ol,{start:"11",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Explain the differences between global path planning and local path planning. When would you use each approach, and how do they complement each other in a complete navigation system?"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Describe the main challenges of navigation in dynamic environments and propose solutions for handling moving obstacles, changing maps, and uncertain localization."}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Compare and contrast different path planning algorithms (A*, Dijkstra, RRT, Potential Fields). What are the advantages and disadvantages of each, and when would you choose one over the others?"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"How does uncertainty affect robot navigation, and what techniques can be used to handle uncertainty in perception, localization, and mapping? How does this impact path planning decisions?"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"answer-key",children:"Answer Key"}),"\n",(0,o.jsx)(e.h3,{id:"multiple-choice-answers",children:"Multiple Choice Answers:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"a) Simultaneous Localization and Mapping"}),"\n",(0,o.jsx)(e.li,{children:"a) Dijkstra's algorithm"}),"\n",(0,o.jsx)(e.li,{children:"a) A* is faster due to heuristic guidance"}),"\n",(0,o.jsx)(e.li,{children:"b) The set of all possible velocities given robot dynamics"}),"\n",(0,o.jsx)(e.li,{children:"b) To represent obstacles and navigation costs in the environment"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"practical-application-answers",children:"Practical Application Answers:"}),"\n",(0,o.jsxs)(e.ol,{start:"6",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Warehouse navigation pipeline:\r\na) Localization: AMCL (Adaptive Monte Carlo Localization) with good landmarks\r\nb) Path planning: Global A* on static costmap with inflation for safety\r\nc) Local planning: DWA or TEB (Timed Elastic Band) for dynamic obstacle avoidance\r\nd) Safety: Emergency stops, safety corridors, velocity limiting near humans"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Hybrid navigation system:\r\na) Global planner provides path, local planner follows while avoiding obstacles\r\nb) Replan when path is blocked, goal changes, or robot deviates significantly\r\nc) Use recovery behaviors like clearing costmap or using backup plans\r\nd) Implement smooth velocity profiles and path smoothing"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"GPS-denied navigation:\r\na) Localization: Visual-inertial odometry, LiDAR SLAM, or UWB positioning\r\nb) Mapping: Occupancy grid maps with loop closure detection\r\nc) Planning: Probabilistic roadmaps or sampling-based methods that consider uncertainty\r\nd) Recovery: Safe stop, return to known location, or human intervention"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"code-analysis-answers",children:"Code Analysis Answers:"}),"\n",(0,o.jsxs)(e.ol,{start:"9",children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Issues with the A* code:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Neighbor validation is incorrect (",(0,o.jsx)(e.code,{children:"if neighbor in [0, 0, 0]"})," compares to a list)"]}),"\n",(0,o.jsx)(e.li,{children:"No check if neighbor is in grid bounds"}),"\n",(0,o.jsx)(e.li,{children:"No check if neighbor is occupied"}),"\n",(0,o.jsxs)(e.li,{children:["Should be: ",(0,o.jsx)(e.code,{children:"if not is_valid_neighbor(neighbor, grid): continue"})]}),"\n",(0,o.jsx)(e.li,{children:"Missing proper neighbor validation function"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Issues with navigation control:"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Wrong order of arguments in atan2 (should be atan2(dy, dx))"}),"\n",(0,o.jsx)(e.li,{children:"Constant linear velocity doesn't account for distance to goal"}),"\n",(0,o.jsx)(e.li,{children:"Always turns right regardless of obstacle position"}),"\n",(0,o.jsx)(e.li,{children:"No proper obstacle avoidance direction calculation"}),"\n",(0,o.jsx)(e.li,{children:"Corrections:"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"angle_to_goal = math.atan2(dy, dx)  # Correct order\r\nlinear_vel = min(max_speed, distance_to_goal * gain)  # Speed based on distance\r\n\r\n# For obstacle avoidance, calculate direction away from obstacles\r\nif dist_to_obs < 1.0:\r\n    linear_vel = 0.0\r\n    # Calculate turn direction based on obstacle position\r\n    obs_angle = math.atan2(obs.y - robot_pose.y, obs.x - robot_pose.x)\r\n    turn_direction = math.atan2(dy, dx) - obs_angle\r\n    angular_vel = math.copysign(1.0, turn_direction)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"conceptual-answers",children:"Conceptual Answers:"}),"\n",(0,o.jsxs)(e.ol,{start:"11",children:["\n",(0,o.jsx)(e.li,{children:"Global vs. Local planning:"}),"\n"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Global planning: Computes path from start to goal using static map, computationally intensive but optimal"}),"\n",(0,o.jsx)(e.li,{children:"Local planning: Short-term path following with obstacle avoidance using sensor data, reactive and fast"}),"\n",(0,o.jsx)(e.li,{children:"Used together: Global provides path, local executes while handling dynamic obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Complement: Global for long-term strategy, local for short-term tactics"}),"\n"]}),"\n",(0,o.jsxs)(e.ol,{start:"12",children:["\n",(0,o.jsx)(e.li,{children:"Dynamic environment challenges:"}),"\n"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Moving obstacles: Predict motion, use velocity obstacles, temporal planning"}),"\n",(0,o.jsx)(e.li,{children:"Changing maps: Continuous mapping, dynamic object tracking, predictive models"}),"\n",(0,o.jsx)(e.li,{children:"Uncertain localization: Sensor fusion, particle filters, map matching"}),"\n",(0,o.jsx)(e.li,{children:"Solutions: Temporal planning, predictive models, robust localization"}),"\n"]}),"\n",(0,o.jsxs)(e.ol,{start:"13",children:["\n",(0,o.jsx)(e.li,{children:"Path planning algorithm comparison:"}),"\n"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A*: Optimal, fast with good heuristic, complete"}),"\n",(0,o.jsx)(e.li,{children:"Dijkstra: Optimal, no heuristic needed, slower than A*"}),"\n",(0,o.jsx)(e.li,{children:"RRT: Good for high-dimensional spaces, probabilistically complete, not optimal"}),"\n",(0,o.jsx)(e.li,{children:"Potential Fields: Simple, reactive, susceptible to local minima"}),"\n",(0,o.jsx)(e.li,{children:"Choose based on environment complexity, dimensionality, and optimality requirements"}),"\n"]}),"\n",(0,o.jsxs)(e.ol,{start:"14",children:["\n",(0,o.jsx)(e.li,{children:"Uncertainty handling:"}),"\n"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Perception: Sensor fusion, uncertainty modeling, robust feature detection"}),"\n",(0,o.jsx)(e.li,{children:"Localization: Particle filters, Kalman filters, multiple hypothesis tracking"}),"\n",(0,o.jsx)(e.li,{children:"Mapping: Probabilistic maps, occupancy grids with uncertainty"}),"\n",(0,o.jsx)(e.li,{children:"Path planning: Risk-aware planning, probabilistic roadmaps, chance-constrained optimization"}),"\n",(0,o.jsx)(e.li,{children:"Impact: More conservative paths, safety margins, replanning when uncertainty is high"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var a=i(6540);const o={},t=a.createContext(o);function s(n){const e=a.useContext(t);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),a.createElement(t.Provider,{value:e},n.children)}}}]);